\section{Scelte implementative}
\label{cap:implementation-choices}

\subsection{Rappresentazione del grafo}
\label{sub:graph-representation}

Gli algoritmi di questo homework operano su grafi non pesati, connessi e non diretti.

% \noindent Come nel precedente homework, per semplificare la logica di indicizzazione dei nodi del grafo, la label dei nodi (originariamente numerata da $1$ a $n$) è decrementata di 1, quindi i nodi sono rappresentati dall'intervallo numerico $[0, n-1]$.

\noindent La classe che rappresenta la Mappa di Adiacenza dei grafi è definita in \codeinline{AdjacencyMapGraph.h} nella cartella \textit{Shared}.\\

\noindent A differenza della \codeinline{AdjacencyMapGraph} del primo homework, tale struttura dati è stata corredata anche da un'ulteriore attributo (chiamato \textit{edge\_count\_map}) di tipo \textit{edge\_count\_map\_t} che permette, dato un arco $(u,v)$ di restituire il numero di archi $(u,v)$ presenti nel multigrafo. Tale struttura dati è stata realizzata attraverso l'uso di \textit{std::unordered\_map} dove la chiave è di tipo \textit{Edge} che rappresenta l'arco $(u,v)$ che si vuole considerare e il valore restituito è di tipo \textit{size\_t} che rappresenta la quantità di archi $(u,v)$ (o analogamente $(v,u)$) nel multigrafo che sussistono tra i vertici $u, v \in V$ del multigrafo. Dunque questa struttura dati permette di tenere traccia della quantità di archi tra le coppie di nodi del grafo man mano che l'algoritmo di Karger contrae il grafo come descritto nella procedura di \codeinline{full\_contration} nella sezione \ref{sub:karger-definition}.\\

\noident Infine tramite la funzione di hash e l'operatore di uguaglianza di \textit{Edge} abbiamo fatto in modo che l'arco $(u,v)$ sia considerato identico all'arco $(v,u)$ in modo da evitare ripetizioni e mantenere una consistenza dei dati inutile. La funzione di hash viene riportato nel listato \ref{listing:hash-fun}.\\

\begin{listing}[!ht]
\begin{minted}{c++}
  // funzione di hash commutativa per Edge
    struct edge_hash {
        std::size_t operator()(const Edge& edge) const noexcept {
            constexpr auto hash_max = std::numeric_limits<size_t>::max();
            const auto& [i, j] = edge;
            return (i * j + (i * i) * (j * j) + (i * i * i) * (j * j * j)) % hash_max;
        }
    };
\end{minted}
\caption{Funzione di hash commutativa per la chiave di tipo Edge della \textit{std::unordered\_map}}
\label{listing:hash-fun}
\end{listing}

\noident Oltre a questa nuova attributo della classe, \codeinline{AdjacencyMapGraph} è stata anche estesa con un nuovo metodo denominato \codeinline{contract}, che presi in input 2 vertici (che chiameremo \textit{contracted} e  \textit{incorporator}), contrae il grafo su quei due vertici. In particolare è stato deciso che \textit{contracted} venga eliminato e tutti gli archi che puntavano ad esso, vengono fatti puntare al nodo \textit{incorporator}. Gli step eseguiti da tale funzione sono i seguenti:
\begin{enumerate}
    \item \textbf{Step 1}: Eliminare tutti gli archi presenti tra \textit{contracted} e \textit{incorportator}, compreso il numero di archi (\textit{contracted}, \textit{incorportator}) da edge\_count\_map.
    
    \item \textbf{Step 2}: Trasferire ogni arco incidente in \textit{contracted} su \textit{incorportator}, aggiornando di conseguenza anche il numero di archi rispettivi in edge\_count\_map.
    
     \item \textbf{Step 3}: Eliminare dal grafo il nodo \textit{contracted}.
\end{enumerate}

\begin{listing}[!ht]
\begin{minted}{c++}

inline void AdjacencyMapGraph::contract(size_t contracted, size_t incorporator) {
    // Step 1
    edge_count_map.erase({contracted, incorporator});
    adj_map[incorporator].erase(contracted);
    adj_map[contracted].erase(incorporator);

    // Step 2
    for (const auto node : adj_map.at(contracted)) {
        adj_map[node].erase(contracted);
        adj_map[node].insert(incorporator);
        adj_map[incorporator].insert(node);

        const size_t n_multi_edge = edge_count_map.at({contracted, node});
        edge_count_map.erase({contracted, node});
        edge_count_map[{incorporator, node}] += n_multi_edge;
    }

    // Step 3
    adj_map.erase(contracted);
}
\end{minted}
\caption{Metodo contract di AdjancencyMapGraph}
\label{listing:met-contract}
\end{listing}


Un'ulteriore metodo aggiunto alla classe, necessario all'algoritmo di Karger per selezionare randomicamente un arco (o meglio i due vertici) da contrarre è il metodo chiamato \codeinline{get\_random\_edge()}. Quest'ultimo si occupa di estrarre in maniera casuale un arco dalla lista di adiacenza del grafo, trasformando temporaneamente la lista di adiacenza in un vettore per poi estrarre da quest'ultimo un elemento in una posizione casuale, dato che std::unordered\_map non offre soluzioni \textit{out-of-the-box} per l'estrazione randomica di una chiave da mappa. Nel caso peggiore questa operazione è lineare sulla taglia degli archi del grafo. Per tale metodo non ne riportiamo il codice, che viene allegato nei file sorgente.

\begin{listing}[!ht]
\begin{minted}{c++}
int main(int argc, char** argv) {
    if (argc != 2) {
        std::cerr << "1 argument required: filename" << std::endl;
        exit(1);
    }

    const char* filename = argv[1];

    // inizia a misurare il tempo di esecuzione
    const auto program_time_start = stopwatch::now();

    // legge il grafo completo non diretto dal file di input
    auto graph = read_file(filename);

    // numero di iterazioni richieste stimato
    const size_t k = // ...
    std::cout << "k: "s << k << '\n';

    // calcola il min-cut approssimato
    const auto min_cut = // ...
    
    // ferma l'orologio
    auto program_time_stop = stopwatch::now();

    // calcola il tempo totale di esecuzione
    const auto program_time =
        stopwatch::duration<stopwatch::us_t>(program_time_start, program_time_stop);

    // stampa la soluzione e le statistiche di esecuzione
    std::cout << "min_cut: "s << min_cut << std::endl;
    std::cout << "program_time: "s << program_time << std::endl;
}
\end{minted}
\caption{Scheletro comune ad ogni file \codeinline{main.cpp} del progetto.}
\label{listing:main-cpp}
\end{listing}

\subsection{Lettura del Grafo}

\noindent Il file \codeinline{main.cpp} ha la stessa struttura per ogni algoritmo, si veda il listing \ref{listing:main-cpp}.
Ci aspettiamo in input file rappresentati come liste di adiacenza, dove, per ogni riga:

\begin{itemize}
    \item la prima colonna indica la label del vertice $u$;
    \item gli elementi successivi formano la lista di tutti i vertici incidenti a $u$, cioè i $v$ tali che \\ $\exists$ $(u, v) \in E$.
\end{itemize}

Ad alto livello, le operazioni svolte sono:

\begin{enumerate}
    \item Lettura del file di input: il file di input viene processato da \codeinline{read\_file.h}. Viene letta una riga per volta in un buffer, e il primo elemento di tale buffer è usato per etichettare il nodo della lista di adiacenza letta.

    \noindent Abbiamo usato la libreria di file streaming nativa di C++ (\codeinline{fstream}).

    \item Una volta letti i nodi, viene creata la Mappa di Adiancenza nella memoria heap, e ne viene ritornato uno \textit{smart-pointer} di tipo \mintinline{c++}{std::shared_ptr}.
\end{enumerate}

\noindent Tutti i file citati qui sopra sono nella cartella \textit{Shared} del progetto consegnato e sono corredati di ulteriori commenti esplicativi.

%\subsection{Strutture Dati comuni}

%Tutte le strutture dati elencate di seguito sono definite nella cartella \textit{Shared}.
%Ove possibile, per la nomenclatura dei metodi abbiamo cercato di seguire lo stesso standard dei container STL di C++.
%Inoltre, le strutture dati usate sono sempre pre-allocate in memoria quando possibile, evitando rehashing e riallocazioni dispendiose. Questo significa che la maggior parte delle operazioni indicate con \complexityConstant{} ammortizzato siano in realtà totalmente costanti nella pratica. \\

\subsection{Misurazione del tempo di esecuzione}
\label{sub:stopwatch}

\noindent \codeinline{C++17} non fornisce soluzione \textit{out-of-the-box} ad alto livello per registrare il tempo di esecuzione di singoli metodi o blocchi di codice. Abbiamo quindi implementato una funzione \codeinline{decorator} che astrae il compito di misurare i tempi di esecuzione di una funzione. \\

\noindent \codeinline{Shared/stopwatch\_decorator.h} definisce la funzione generica \codeinline{decorator}, che:

\begin{itemize}
    \item riceve in input la funzione \codeinline{func} da eseguire e misurare;
    \item ritorna un'altra funzione che riceve in input i parametri variadici \codeinline{args} della funzione \codeinline{func};
    \item all'interno della funzione ritornata, viene avviato un cronometro;
    \item viene eseguita la funzione e ne viene catturato il risultato in una variabile contenitore;
    \item viene interrotto il cronometro e salvato il tempo di esecuzione;
    \item viene ritornato il risultato della funzione corredato del tempo di esecuzione. Ci sono due possibilità:
    \begin{enumerate}
        \item se \codeinline{func(args...)} ritorna una tupla (\mintinline{c++}{std::tuple<...>}), il tempo di esecuzione è appeso in coda al risultato della funzione;
        \item se invece \codeinline{func(args)...} ritorna un qualsiasi altro tipo, viene creata una nuova tupla contenente il risultato della funzione e il tempo di esecuzione.
    \end{enumerate}
\end{itemize}

Si veda il listing \ref{listings:stopwatch-decorator} per un estratto della funzione \codeinline{decorator}.
Si veda invece il listing \ref{listings:stopwatch-decorator-usage} per un'esempio di utilizzo di tale funzione.

\begin{listing}[!ht]
\begin{minted}{c++}
template <typename TimeDuration, typename F>
auto decorator(F&& func) {
  return [func = std::forward<F>(func)](auto&&... args) {
    auto start_time = stopwatch::now();
    
    // la funzione viene eseguita e il risultato è salvato
    using result_t = std::invoke_result_t<F, decltype(args)...>;
    detail::return_wrapper<result_t> result(func,
                                            std::forward<decltype(args)>(args)...);

    const auto stop_time = stopwatch::now();
    const auto func_duration = stopwatch::duration<TimeDuration>(start_time,
                                                                 stop_time);

    // a prescindere dal tipo di ritorno generico della funzione, viene ritornata
    // una tupla non annidata
    if constexpr (detail::is_tuple<result_t>::value) {
      return std::tuple_cat(result.value(), std::tie(func_duration));
    } else {
      return std::make_tuple(result.value(), func_duration);
    }
  };
}
\end{minted}
\caption{Estratto della funzione \codeinline{decorator} per rilevare i tempi di esecuzione di una funzione.}
\label{listings:stopwatch-decorator}
\end{listing}


\begin{listing}[!ht]
\begin{minted}{c++}
auto graph = // ...
const size_t k = // ...
const auto program_time_start = // ...

// min_cut e discovery_time sono risultati della funzione karger
// karger_duration è il tempo di esecuzione della funzione in microsecondi
const auto [min_cut, discovery_time, karger_duration] =
    stopwatch::decorator<stopwatch::us_t>(karger)(graph, k, program_time_start);

\end{minted}
\caption{Esempio di utilizzo della funzione \codeinline{decorator} per rilevare i tempi di esecuzione di una funzione.}
\label{listings:stopwatch-decorator-usage}
\end{listing}

\subsection{Timeout per Karger}

\noindent L'algoritmo di Karger ha complessità temporale \complexityKargerTime{}, quindi i tempi di esecuzione tendono ad aumentare di molto in base al numero di nodi del grafo di input. Per questo motivo abbiamo deciso, in maniera analoga a quanto fatto per l'homework 2 di creare un progetto dove all'algoritmo di Karger abbiamo aggiunto un timeout di esecuzione $T$. Abbiamo fissato il valore di $T$ a 2 minuti.\\

\noindent La nostra implementazione di Karger, quindi:

\begin{enumerate}
    \item Ritorna il min\_cut migliore trovato in k esecuzioni di \codeinline{full\_contraction} se i suoi tempi di esecuzione sono inferiori a $T$ minuti, senza aspettare lo scadere del timeout;
    \item Se invece il timeout scade, termina preventivamente le k esecuzioni di \codeinline{full\_contraction} e ritorna il miglior min\_cut trovato fino a quel momento. A seconda del tempo impiegato da una singola esecuzione di \codeinline{full\_contraction}, l'algoritmo potrebbe ritornare il valore dopo qualche secondo dello scadere del timeout.
\end{enumerate}

\noindent C++17 non fornisce soluzione \textit{out-of-the-box} ad alto livello per eseguire funzioni con un limite di tempo. Abbiamo quindi implementato un meccanismo di questo tipo in \codeinline{Shared/timeout.h}, il cui funzionamento ad alto livello è il seguente:

\begin{itemize}
    \item Il thread principale crea un \textit{worker thread} incaricandolo di eseguire la funzione passata (in questo caso l'algoritmo di Karger) sul grafo letto in input. Fa quindi partire il timeout e resta in attesa del risultato del worker thread. Tale risultato sarà disponibile da un \codeinline{std::future}.
    \item Se il worker thread termina prima dello scadere del timeout, il thread principale è immediatamente sbloccato e il risultato della funzione (restituito da \codeinline{std::future::get()}) è ritornato al chiamante.
    \item Se il timeout scade e il worker thread non ha ancora terminato l'esecuzione, il thread principale gli notifica di terminare l'esecuzione il prima possibile. Tale notifica avviene forzando la conclusione di una \codeinline{std::promise} creata dal main thread e data in input alla funzione eseguita incapsulata nella classe \codeinline{timeout\_signal}.
    \item Quando la funzione eseguita si accorge che il tempo a disposizione è scaduto, interrompe la ricorsione e ritorna al chiamante la migliore soluzione individuata fino a quel momento.
\end{itemize}