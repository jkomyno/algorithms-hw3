\section{Scelte implementative}
\label{cap:implementation-choices}

\subsection{Rappresentazione del grafo}
\label{sub:graph-representation}

Gli algoritmi di questo homework operano su (multi)grafi non pesati,
connessi e non diretti.\\

% \noindent Come nel precedente homework, per semplificare la logica di indicizzazione dei nodi del grafo, la label dei nodi (originariamente numerata da $1$ a $n$) è decrementata di 1, quindi i nodi sono rappresentati dall'intervallo numerico $[0, n-1]$.

\noindent La classe che rappresenta la Mappa di Adiacenza dei grafi è
definita in \codeinline{AdjacencyMapGraph.h} nella cartella
\textit{Shared}. Rispetto alla classe utilizzata nei precedenti
homework, sono state effettuate alcune modifiche per supportare nuove
funzionalità richieste dal problema. Queste estensioni sono elencate
di seguito.

\paragraph{Multigrafo}
\codeinline{AdjacencyMapGraph} è stata corredata da un'ulteriore
attributo (chiamato \codeinline{edge\_count\_map}) di tipo
\codeinline{edge\_count\_map\_t} che permette, dato un arco $(u,v)$ di
accedere al numero di archi $(u,v)$ presenti nel multigrafo. Tale
struttura dati è stata realizzata attraverso l'uso di
\codeinline{std::unordered\_map}. La chiave della mappa è di tipo
\codeinline{Edge} e rappresenta il generico arco $(u,v)$, mentre il
valore è di tipo \codeinline{size\_t} e rappresenta la quantità di
archi $(u,v)$, o analogamente $(v,u)$. Questa struttura dunque, dati
permette di tenere traccia della quantità di archi tra le coppie di
nodi del grafo man mano che l'algoritmo di Karger contrae il grafo
come descritto nella procedura di \codeinline{full\_contration} nella
sezione \ref{sub:karger-definition}.\\

\noindent Infine tramite la funzione di hash e l'operatore di
uguaglianza di \codeinline{Edge} abbiamo fatto in modo che l'arco $(u,v)$
sia considerato identico all'arco $(v,u)$ in modo da evitare
ripetizioni e mantenere una consistenza dei dati inutile. La funzione
di hash viene riportata nel listato \ref{listing:hash-fun}.

\begin{listing}[!ht]
\begin{minted}{c++}
// funzione di hash commutativa per Edge
struct edge_hash {
    std::size_t operator()(const Edge& edge) const noexcept {
        constexpr auto hash_max = std::numeric_limits<size_t>::max();
        const auto& [i, j] = edge;
        return (i * j + (i * i) * (j * j) + (i * i * i) * (j * j * j)) % hash_max;
    }
};
\end{minted}
\caption{Funzione di hash commutativa per la chiave di tipo Edge della \textit{std::unordered\_map}}
\label{listing:hash-fun}
\end{listing}

\paragraph{Contrazione di due nodi}
Si è reso necessario estendere ulteriormente
\codeinline{AdjacencyMapGraph} con un nuovo metodo denominato
\codeinline{contract}. Quest'ultimo, dati due vertici
\textit{contracted} e \textit{incorporator}, effettua la contrattura
del grafo. In particolare è stato deciso che \textit{contracted} venga
eliminato e tutti gli archi che puntavano ad esso, vengono fatti
puntare al nodo \textit{incorporator}.

\noindent Gli step eseguiti da tale funzione sono i seguenti:
\begin{enumerate}
    \item Eliminare tutti gli archi presenti tra
      \textit{contracted} e \textit{incorportator}, compreso il numero
      di archi (\textit{contracted}, \textit{incorportator}) da
      \codeinline{edge\_count\_map}.
    
    \item Trasferire ogni arco incidente in
      \textit{contracted} su \textit{incorportator}, aggiornando di
      conseguenza anche il numero di archi rispettivi in
      \codeinline{edge\_count\_map}.
    
    \item Eliminare dal grafo il nodo
       \textit{contracted}.
\end{enumerate}
Il listato \ref{listing:met-contract} ne riporta l'implementazione.

\begin{listing}[!ht]
\begin{minted}{c++}

inline void AdjacencyMapGraph::contract(size_t contracted, size_t incorporator) {
    // Step 1
    edge_count_map.erase({contracted, incorporator});
    adj_map[incorporator].erase(contracted);
    adj_map[contracted].erase(incorporator);

    // Step 2
    for (const auto node : adj_map.at(contracted)) {
        adj_map[node].erase(contracted);
        adj_map[node].insert(incorporator);
        adj_map[incorporator].insert(node);

        const size_t n_multi_edge = edge_count_map.at({contracted, node});
        edge_count_map.erase({contracted, node});
        edge_count_map[{incorporator, node}] += n_multi_edge;
    }

    // Step 3
    adj_map.erase(contracted);
}
\end{minted}
\caption{Metodo contract di AdjancencyMapGraph}
\label{listing:met-contract}
\end{listing}

\paragraph{Selezione di arco in modo casuale}
Un'ulteriore metodo aggiunto alla classe, necessario all'algoritmo di
Karger per la selezione randomica di un arco (o meglio i due vertici)
da contrarre, è il metodo \codeinline{get\_random\_edge()}.
Quest'ultimo si occupa di estrarre in maniera casuale un arco dalla
lista di adiacenza del grafo. Dato che
\codeinline{std::unordered\_map} non offre soluzioni
\emph{out-of-the-box} per l'estrazione randomica di una chiave dalla
mappa, abbiamo dovuto implementare questa operazione da
zero. \codeinline{get\_random\_edge()}, quindi, trasforma
temporaneamente la lista di adiacenza in un vettore, e successivamente
ne seleziona un elemento in posizione casuale. Nel caso peggiore
questa operazione è lineare sulla taglia degli archi del
grafo. L'implementazione di tale metodo non viene riportata,
rimandiamo invece ai sorgenti allegati alla relazione.

\subsection{Lettura del Grafo}

\noindent Il file \codeinline{main.cpp} ha la stessa struttura per
ogni algoritmo, come riportato nel listato \ref{listing:main-cpp}.

\begin{listing}[!ht]
\begin{minted}{c++}
int main(int argc, char** argv) {
    if (argc != 2) {
        std::cerr << "1 argument required: filename" << std::endl;
        exit(1);
    }

    const char* filename = argv[1];

    // inizia a misurare il tempo di esecuzione
    const auto program_time_start = stopwatch::now();

    // legge il grafo completo non diretto dal file di input
    auto graph = read_file(filename);

    // numero di iterazioni richieste stimato
    const size_t k = // ...
    std::cout << "k: "s << k << '\n';

    // calcola il min-cut approssimato
    const auto min_cut = // ...
    
    // ferma l'orologio
    auto program_time_stop = stopwatch::now();

    // calcola il tempo totale di esecuzione
    const auto program_time =
        stopwatch::duration<stopwatch::us_t>(program_time_start, program_time_stop);

    // stampa la soluzione e le statistiche di esecuzione
    std::cout << "min_cut: "s << min_cut << std::endl;
    std::cout << "program_time: "s << program_time << std::endl;
}
\end{minted}
\caption{Scheletro comune ad ogni file \codeinline{main.cpp} del progetto.}
\label{listing:main-cpp}
\end{listing}

L'input di ogni programma è un file, il cui contenuto una lista di
adiacenza, dove, per ogni riga:

\begin{itemize}
    \item la prima colonna indica la label del vertice $u$;
    \item gli elementi successivi formano la lista di tutti i vertici
      incidenti a $u$, cioè i $v$ tali che \\ $\exists$ $(u, v) \in
      E$.
\end{itemize}

\noiindet Ad alto livello, le operazioni svolte da ogni programma sono:

\begin{enumerate}
    \item Lettura dell'input: il file di input viene processato
      da \codeinline{read\_file.h}. Viene letta una riga per volta in
      un buffer, e il primo elemento di tale buffer è usato per
      etichettare il nodo della lista di adiacenza letta.

    \noindent Abbiamo usato la libreria di file streaming nativa di
    C++ (\codeinline{fstream}).

    \item Una volta letti i nodi, viene creata la Mappa di Adiancenza
      nella memoria heap, e ne viene ritornato uno
      \textit{smart-pointer} di tipo
      \mintinline{c++}{std::shared_ptr}.
\end{enumerate}

\noindent Tutti i file citati precedentemento sono locati nella
cartella \textit{Shared} del progetto consegnato e sono corredati di
ulteriori commenti esplicativi.

%\subsection{Strutture Dati comuni}

%Tutte le strutture dati elencate di seguito sono definite nella cartella \textit{Shared}.
%Ove possibile, per la nomenclatura dei metodi abbiamo cercato di seguire lo stesso standard dei container STL di C++.
%Inoltre, le strutture dati usate sono sempre pre-allocate in memoria quando possibile, evitando rehashing e riallocazioni dispendiose. Questo significa che la maggior parte delle operazioni indicate con \complexityConstant{} ammortizzato siano in realtà totalmente costanti nella pratica. \\

\subsection{Misurazione del tempo di esecuzione}
\label{sub:stopwatch}

\noindent \codeinline{C++17} non fornisce soluzione
\textit{out-of-the-box} ad alto livello per registrare il tempo di
esecuzione di singoli metodi o blocchi di codice. Abbiamo quindi
implementato una funzione \codeinline{decorator} che astrae il compito
di misurare i tempi di esecuzione di una funzione. \\

\noindent \codeinline{Shared/stopwatch\_decorator.h} definisce la
funzione generica \codeinline{decorator}, che:

\begin{itemize}
    \item riceve in input la funzione \codeinline{func} da eseguire e
      misurare;
    \item ritorna un'altra funzione che riceve in input i parametri
      variadici \codeinline{args} della funzione \codeinline{func};
    \item all'interno della funzione ritornata, viene avviato un
      cronometro;
    \item viene eseguita la funzione e ne viene catturato il risultato
      in una variabile contenitore;
    \item viene interrotto il cronometro e salvato il tempo di
      esecuzione;
    \item viene ritornato il risultato della funzione corredato del
      tempo di esecuzione. Ci sono due possibilità:
    \begin{enumerate}
        \item se \codeinline{func(args...)} ritorna una tupla
          (\mintinline{c++}{std::tuple<...>}), il tempo di esecuzione
          è appeso in coda al risultato della funzione;
        \item se invece \codeinline{func(args)...} ritorna un
          qualsiasi altro tipo, viene creata una nuova tupla
          contenente il risultato della funzione e il tempo di
          esecuzione.
    \end{enumerate}
\end{itemize}

Si veda il listing \ref{listings:stopwatch-decorator} per un estratto
della funzione \codeinline{decorator}.  Si veda invece il listing
\ref{listings:stopwatch-decorator-usage} per un'esempio di utilizzo di
tale funzione.

\begin{listing}[!ht]
\begin{minted}{c++}
template <typename TimeDuration, typename F>
auto decorator(F&& func) {
  return [func = std::forward<F>(func)](auto&&... args) {
    auto start_time = stopwatch::now();
    
    // la funzione viene eseguita e il risultato è salvato
    using result_t = std::invoke_result_t<F, decltype(args)...>;
    detail::return_wrapper<result_t> result(func,
                                            std::forward<decltype(args)>(args)...);

    const auto stop_time = stopwatch::now();
    const auto func_duration = stopwatch::duration<TimeDuration>(start_time,
                                                                 stop_time);

    // a prescindere dal tipo di ritorno generico della funzione, viene ritornata
    // una tupla non annidata
    if constexpr (detail::is_tuple<result_t>::value) {
      return std::tuple_cat(result.value(), std::tie(func_duration));
    } else {
      return std::make_tuple(result.value(), func_duration);
    }
  };
}
\end{minted}
\caption{Estratto della funzione \codeinline{decorator} per rilevare i
  tempi di esecuzione di una funzione.}
\label{listings:stopwatch-decorator}
\end{listing}


\begin{listing}[!ht]
\begin{minted}{c++}
auto graph = // ...
const size_t k = // ...
const auto program_time_start = // ...

// min_cut e discovery_time sono risultati della funzione karger
// karger_duration è il tempo di esecuzione della funzione in microsecondi
const auto [min_cut, discovery_time, karger_duration] =
    stopwatch::decorator<stopwatch::us_t>(karger)(graph, k, program_time_start);

\end{minted}
\caption{Esempio di utilizzo della funzione \codeinline{decorator} per
  rilevare i tempi di esecuzione di una funzione.}
\label{listings:stopwatch-decorator-usage}
\end{listing}

\subsection{Timeout per Karger}

\noindent L'algoritmo di Karger ha complessità temporale
\complexityKargerTime{}, quindi i tempi di esecuzione tendono ad
aumentare di molto in base al numero di nodi del grafo di input. Per
questo motivo abbiamo deciso, in maniera analoga a quanto fatto per
l'algoritmo di Held \& Karp dell'\emph{homework 2}, di creare un progetto
dove all'algoritmo di Karger abbiamo aggiunto un timeout di esecuzione
$T$. Abbiamo fissato il valore di $T$ a 2 minuti.\\

\noindent La nostra implementazione di Karger con Timeout, quindi:

\begin{enumerate}
    \item Ritorna il min\_cut migliore trovato in k esecuzioni di
      \codeinline{full\_contraction} se i suoi tempi di esecuzione
      sono inferiori a $T$ minuti, senza aspettare lo scadere del
      timeout;
    \item Se invece il timeout scade, termina preventivamente le k
      esecuzioni di \codeinline{full\_contraction} e ritorna il
      miglior min\_cut trovato fino a quel momento. A seconda del
      tempo impiegato da una singola esecuzione di
      \codeinline{full\_contraction}, l'algoritmo potrebbe ritornare
      il valore dopo qualche secondo dello scadere del timeout.
\end{enumerate}

\noindent C++17 non fornisce soluzione \textit{out-of-the-box} ad alto
livello per eseguire funzioni con un limite di tempo. Abbiamo quindi
implementato un meccanismo di questo tipo in
\codeinline{Shared/timeout.h}, il cui funzionamento ad alto livello è
il seguente:

\begin{itemize}
    \item Il thread principale crea un \textit{worker thread}
      incaricandolo di eseguire la funzione passata (in questo caso
      l'algoritmo di Karger) sul grafo letto in input. Fa quindi
      partire il timeout e resta in attesa del risultato del worker
      thread. Tale risultato sarà disponibile da un
      \codeinline{std::future}.
    \item Se il worker thread termina prima dello scadere del timeout,
      il thread principale è immediatamente sbloccato e il risultato
      della funzione (restituito da \codeinline{std::future::get()}) è
      ritornato al chiamante.
    \item Se il timeout scade e il worker thread non ha ancora
      terminato l'esecuzione, il thread principale gli notifica di
      terminare l'esecuzione il prima possibile. Tale notifica avviene
      forzando la conclusione di una \codeinline{std::promise} creata
      dal main thread e data in input alla funzione eseguita
      incapsulata nella classe \codeinline{timeout\_signal}.
    \item Quando la funzione eseguita si accorge che il tempo a
      disposizione è scaduto, interrompe la ricorsione e ritorna al
      chiamante la migliore soluzione individuata fino a quel momento.
\end{itemize}

\noindent Dato lo scarso valore aggiunto dal punto di vista del
codice, l'implementazione dell'algoritmo di Karger con il timeout non
è riportata sulla relazione; si rimanda invece ai sorgenti allegati
per la consultazione della stessa.
